106 安装vue Cli
    vue -V查看版本
    npm update -g @vue/cli 升级最新
    npm init @vitejs/app wo
    vue create @vitejs/app
    vue create xxx
    cd xxx
    npm install
    npm install vue-loader-v16
    npm install vue-router@4
    npm run serve

107 目录剖析
    dependencies 生产依赖
    devDependencies 开发依赖

    assets 放音频 图片
    components 放局部组件
    pages 页面级别组件
    APP.vue 项目级别组件汇聚地
    main.js 输出项目级别组件

109 体验案例1
    style scoped 节流不让其他组件使用
110 2

111 3

122 概念路由
    
123 后端渲染

124 前后端分离

125 前端路由
    单页面应用程序

126 history和hash
    hash 通过监听浏览器的onhashchange()事件变化，查找对应的路由规则 #/

    利用HTML5 History Interface 中新增的pushState() 和replaceState()

127 项目集成VueRouter

128 基本使用
     {path:'/',redirect:'home'},

129 模式选择
    hash 在内部传递的实际URL之前使用了一个哈希字符
    这部分URL从未被发送到服务器，不需要在服务器层面上进行任何特殊处理

    history 用户在浏览器直接访问嵌套路由时会404
    需在服务器添加一个回退路由

130 activeClass
    active-class="cuttent" 选中样式
    简化直接配置
    .router-link-active{}

    在index中设置 linkActiveClass:'xx'
    .xx{}

131 js实现路由
    replace 不能退回前进

    import router from "./router";
    @click="home()"
    const home=()=>{
        router.push('/home')
    }

132 动态路由
     {path:'/news/:id',component:News},
     {{$route.params.id}} 当前活动的 router全局

     import {useRoute} from 'vue-router'
       const route =useRoute()
        console.log(route.params.id);

133 路由懒加载
    const Home=()=>import('./../components/Home.vue')

134 路由嵌套
       children:[
            {path:'msg',component:MineMsg},
            {path:'order',component:MineOrder}
        ]
        在父路由里 子不用/

135 参数传递
    params
    query
    :to="{path:'/circle',query:{name:'lk',age:10}}"
    {{$route.query.name}}
      let route = useRoute()
    console.log(route.query);
136 
        const news = () => {
      router.push("/news/" + newsId.value);
    };
    const circle = () => {
      router.push({
        path: "/circle",
        query: { name: "l22k", site: "it.com", age: 10 },
      });
    };
    
137 router和route

138 路由全局前置守卫
    在进入路由前
    一个路由匹配到的所有路由记录会暴露为
     $route 对象(还有在导航守卫中的路由对象)的$route.matched 数组。
     我们需要遍历这个数组来检查路由记录中的 meta 字段，
     但是 Vue Router 还为你提供了一个 $route.meta 方法，
     它是一个非递归合并所有 meta 字段的

     ,meta:{title:'首页'}
     router.beforeEach((to, from, next) => {
    document.title = to.meta.title
    next()
        }
    )
    
139 组件内守卫
    引入onBeforeRouteLeave,onBeforeRouteUpdate

140 keep alive
    vue2
    keep-alive
        router-view

    vue3
      <router-view v-slot="{Component}">
      <keep-alive>
        <component :is="Component"></component>
      </keep-alive>
    </router-view>

141
    include-string|RegExp|Array 只有名称匹配的组件会被缓存
    exclude-string|RegExp|Array 任何名称匹配的组件都不会被缓存
    max-number|string 最多可以缓存多少组件实例

    在路由配置keepAlive:true
     <keep-alive>
        <component :is="Component" v-if="$route.meta.keepAlive"></component>
      </keep-alive>
          <component :is="Component" v-if="!$route.meta.keepAlive"></component>

















